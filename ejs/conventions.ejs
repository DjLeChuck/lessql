<section id="conventions">

<h1>Conventions <small>and Workarounds</small></h1>

<p>LessQL relies entirely on two conventions:</p>

<ul>
	<li>Primary key columns should be <code>id</code> and</li>
	<li>foreign key columns should be <code>&lt;table&gt;_id</code>.</li>
</ul>

<div class="note">
	<p>A side effect of these conventions is to use <strong>singular table names</strong>,
		because plurals are irregular and <code>product.categories_id</code> sounds wrong.</p>
</div>

<p>More often than not, these conventions are not enough to work with your database,
and workarounds are needed. You will most likely have join
tables with compound primary keys. Or you might have
two columns in one table pointing to the same foreign table.</p>

<p>LessQL provides solutions for all of these use cases.
This section contains real-world examples showing how to define
alternate primary keys, assocations and reference keys.</p>

<div class="note">
	<p>Because SQL is case-insensitive, you should always use
		<code>snake_case</code> for table names, column names, and aliases.</p>
</div>

<h2>Required columns</h2>

<p>When saving complex structures, LessQL needs a way to know which
columns and especially foreign keys are required (<code>NOT NULL</code>).
This way, rows with required columns are saved last with all their foreign
keys set.</p>

<p>Whenever you get "some column may not be null" exceptions, this should solve that.</p>

<pre><code data-language="php">
$db-&gt;setRequired( 'post', 'user_id' );
</code></pre>

<h2>Alternate foreign keys</h2>

<p>You can use alternate foreign keys in associations using <code>via</code>:</p>

<pre><code data-language="php">
foreach ( $db-&gt;post() as $post ) {

	// single: use post.author_id instead of post.user_id
	$author = $post-&gt;user()-&gt;via( 'author_id' )-&gt;fetch();

	// list: use category.featured_post_id instead of category.post_id
	$featureCategories = $post-&gt;categoryList()-&gt;via( 'featured_post_id' );

}
</code></pre>

<p>This is quick and easy, but repetitive. It is often better to
define these things globally using one of the following methods.</p>

<h2>Table Aliasing</h2>

<p>Let <code>customer</code> have columns <code>address_id</code> and <code>billing_address_id</code>.
Both columns point to the <code>address</code> table, but the
association <code>billing_address</code> would try to query
the <code>billing_address</code> table. For this
situation, LessQL lets you define <strong>table aliases</strong>:</p>

<pre><code data-language="php">
$db-&gt;setAlias( 'billing_address', 'address' );
$db-&gt;customer()-&gt;billing_address();
</code></pre>

<p>This association will use <code>customer.billing_address_id</code>
as reference key and <code>address</code> as table.
Note how we are using the association name, <em>not</em> the table name.</p>

<h2>Back References</h2>

<p>Consider again the use case from above. Let's try to access the
data the other way around: Starting with an address,
how would you get users that point to it via <code>billing_address_id</code>?
The solution is using <strong>back references</strong> and aliases and looks like this:</p>

<pre><code data-language="php">
$db-&gt;address()-&gt;userList(); // works by convention

$db-&gt;setAlias( 'user_billing', 'user' );
$db-&gt;setBackReference( 'address', 'user_billing', 'billing_address_id' );
$db-&gt;address()-&gt;user_billingList();
</code></pre>

<p>Setting a back reference key in this case states:
<code>address</code> is referenced by <code>user_billing</code> using
<code>billing_address_id</code>.</p>

<h2>Alternate Primary Keys</h2>

<p>Primary keys should be named <code>id</code>, but if a primary key goes by a
different column name you can override it easily with
<code>$db-&gt;setPrimary( 'user', 'uid' )</code>.</p>

<p>Compound primary keys are also possible and
especially useful for join tables:
<code>$db-&gt;setPrimary( 'categorization', array( 'post_id', 'category_id' ) )</code>.</p>

<p><strong>You should always define compound keys manually.</strong> Without these definitions,
saving nested structures may fail because LessQL cannot know which
columns are required for a complete primary key.
</p>

<h2>Alternate Reference Keys</h2>

<p>Foreign keys should be named <code>&lt;table&gt;_id</code>, but if a foreign key goes by a
different column name you can override it easily with
<code>$db-&gt;setReference( 'post', 'user', 'uid' )</code>,
which basically states the following: <code>post</code> references <code>user</code>
using the column <code>uid</code>.</p>

<p>We're using the term <em>reference</em> to distinguish from <em>back references</em>,
as both use foreign keys.</p>

<h2>Table prefixes <small>and other custom table schemes</small></h2>

<p>To add a prefix to your tables, you can define a table rewrite function:</p>

<pre><code data-language="php">
$db-&gt;setRewrite( function( $table ) {

	return 'prefix_' . $table;

} );
</code></pre>

<p>The function is completely arbitrary and will rewrite tables directly before executing any query.</p>

</section>

<% var buffer = __output.join( '' ); __output.length = 0; %>
<%- include( 'layout.ejs', { main: buffer } ) %>
